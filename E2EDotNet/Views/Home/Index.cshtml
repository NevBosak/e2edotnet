@{ 
/*============================================================================
Nevelex Proprietary
Copyright 2018 Nevelex Corporation
UNPUBLISHED WORK
ALL RIGHTS RESERVED
This software is the confidential and proprietary information of
Nevelex Corporation ("Proprietary Information"). Any use, reproduction,
distribution or disclosure of the software or Proprietary Information,
in whole or in part, must comply with the terms of the license
agreement, nondisclosure agreement or contract entered into with
Nevelex providing access to this software.
==============================================================================*/
}

@model E2EDotNet.Models.E2EScreen

@{
    ViewBag.Title = "Index";
    Layout = "~/Views/Shared/_Layout.cshtml";
}

<h2>E2E Test Runner</h2>


<table class="table" id="testTable">
    <tr>

        <th>
            Test name
        </th>
        <th>
            Status
        </th>
        <th>
            Test description
        </th>
        <th>Enabled</th>
        <th></th>
    </tr>
    @foreach (var test in Model.Tests)
    {
    <tr id="test_@test.ID">
        <td>@test.Name</td>
        <td id="test_status_@test.ID">
            @if (test.IsCompleted)
            {
                if (test.ErrorMessage != null)
                {
                    <span style="color:red;">Error:<br /><pre style="background-color:gray;color:black;">@test.ErrorMessage</pre></span>
                }
                else
                {
                    <span style="color:green">Completed</span>
                }
            }
            else
            {
                <span>Not Completed</span>
            }
        </td>
        <td>@test.Description</td>
        <td><input type="checkbox" checked="checked" class="testCheckbox" /></td>
    </tr>
        //#pstein: minor nit in formatting here, awkward that this close brace is not in same column as matching opening brace.
        // REPLY (bbosak): Fixed.
    }
</table>

<div id="highLevelStatus">
    @if (Model.IsRunning)
    {
        <span>Completed @Model.SelectedTests.Where(m => m.IsCompleted).Count() of @Model.SelectedTests.Count</span>
    }
    else
    {
        <span>No tests are running.</span>
    }
</div>
<select id="browserSelection">
#pstein: As mentioned in the C# side, I'd much prefer value="chrome" here
    <option value="Chrome">Chrome</option>
    <option value="Remote">Remote browser via Selenium wire protocol</option>
</select>
<input type="text" id="remoteHost" style="display:none" />
<input type="button" value="Start tests" id="startStopBtn" />

@section scripts {
    <script type="text/javascript">
        $(document).ready(function () {
// #pstein: I don't have a problem with this, but isn't JQuery installed and wouldn't it simplify a bunch of the getElement*() calls here?
            //REPLY (bbosak): Fixed.
            var browserSelection = $('#browserSelection')[0];
            var remoteHost = $('#remoteHost')[0];
            var enabledTests = {};
            browserSelection.onchange = function () {
                if (browserSelection.value == 'Remote') {
                    remoteHost.style.display = '';
                } else {
                    remoteHost.style.display = 'none';
                }
            };
            var isRunning = @(Model.IsRunning ? "true" : "false");
            var testCount = @Model.SelectedTests.Count;
            var startStopBtn = $('#startStopBtn')[0];
            var firstTest = $('#test_0')[0];
            var i = 0;
            for (var test = firstTest; test != null; test = test.nextSibling) {
                if (test.nodeType == Node.ELEMENT_NODE) {
// #pstein: What am I missing here, the checkbox looks to me to be the fourth sibling... or do you also have to skip the whitespace between the TD elements?
                    // #pstein: I would prefer either giving the checkbox an ID tag or using the queryBySelector to find td>input[type="checkbox"]
                    // REPLY (bbosak): Fixed. Gave the checkboxes a class that can be jQueried.
                    test.testInfo = { id: i, enableCheckbox: $(test).find('.testCheckbox')[0] };
                    i++;
                }
            }
            var highLevelStatus = $('#highLevelStatus')[0];
            var lastUpdatedID = 0;
            var doLongPoll = function () {
// #pstein: As mentioned in the code, use different actions rather than different 'op' integers (throughout)
                // REPLY (bbosak): Fixed.
                $.post('@Url.Action("LongPoll")').done(function (data) {

                    if (data.op == 0) {
                        //All tests complete
                        highLevelStatus.innerText = 'No tests are running.';
                        isRunning = false;
                        startStopBtn.value = 'Start tests';
// #pstein: Why do a long poll if no tests are running? Do we expect someone else to run tests and the results to show on our browser, too?
                        // REPLY (bbosak): Fixed.
                        return;
                    }
                    $.post('@Url.Action("GetTestInfo")', JSON.stringify({ id: lastUpdatedID }), function (data) {
                        var completed = data.completed;
                        testCount = data.testCount;
                        var list = data.list;
                        for (var i = 0; i < list.length; i++) {
                            var test = list[i];
                            if (test.completed) {
                                var elem = $('#test_status_' + test.id)[0];
                                elem.innerHTML = '';
                                if (test.errorMessage) {
                                    elem.style.color = 'red';
                                    var span = document.createElement('span');
                                    span.innerText = 'Error:';
                                    elem.appendChild(span);
                                    var pre = document.createElement('pre');
                                    pre.style.backgroundColor = 'gray';
                                    pre.innerText = test.errorMessage;
                                    elem.appendChild(pre);
                                } else {
                                    elem.style.color = 'green';
                                    var span = document.createElement('span');
                                    span.innerText = 'Completed';
                                    elem.appendChild(span);
                                }
                                if (test.id > lastUpdatedID) {
                                    lastUpdatedID = test.id;
                                }
                            }

                            if (testCount) {
                                highLevelStatus.innerText = 'Completed ' + completed + ' of ' + testCount;
                            }
                        }
                    });
// #pstein: can this be a 'finally' instead of a catch' and eliminate having to call doLongPoll() in every return path above?
                    // REPLY (bbosak): Fixed.
                }).always(function () {
                    if (isRunning) {
                        doLongPoll();
                    }
                });
            };
            startStopBtn.onclick = function () {
                if (isRunning) {
                    $.post('@Url.Action("AbortTests")');
                    startStopBtn.value = 'Start tests';
                    isRunning = false;
                } else {
                    var tests = [];
                    enabledTests = {};
                    lastUpdatedID = 0;
                    for (var test = firstTest; test != null; test = test.nextSibling) {
                        if (test.nodeType == Node.ELEMENT_NODE) {
                            if (test.testInfo.enableCheckbox.checked) {
                                tests.push(test.testInfo.id);
                                enabledTests[test.testInfo.id] = true;
                            }
                        }
                    }
                    testCount = tests.length;
                    highLevelStatus.innerText = 'Completed 0 of ' + testCount;
                    // #pstein: Assuming you change the browser selection to a string instead, then you'll have to not OR it with 0 here to cast to int.
                    doLongPoll();
                    $.post('@Url.Action("RunTests")', JSON.stringify({ tests: tests, browser: browserSelection.value, host: remoteHost.value }));
                    startStopBtn.value = 'Stop tests';
                    isRunning = true;
                }
            };
        });
    </script>
}
